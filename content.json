{"meta":{"title":"tangll","subtitle":null,"description":"唐龙隆个人博客","author":"tangll","url":"https://gtntangll.github.io"},"pages":[],"posts":[{"title":"Nginx作为负载均衡服务","slug":"Nginx作为负载均衡服务","date":"2018-06-12T09:46:52.000Z","updated":"2018-06-12T10:12:10.000Z","comments":true,"path":"2018/06/12/Nginx作为负载均衡服务/","link":"","permalink":"https://gtntangll.github.io/2018/06/12/Nginx作为负载均衡服务/","excerpt":"","text":"一、介绍1.负载均衡 单位时间内一台服务器的访问量过大将会使服务器的压力变大，压力难以承受时甚至会导致服务器崩溃。负载均衡服务就是为了避免这样的事情发生。负载均衡就是通过建立一个服务器群，当用户访问资源时先通过一个中间服务器将这次的访问引到服务器群里压力较小服务器去访问。使用这样的方式就可以平衡了服务器的压力,充分发挥了服务器群的性能。 2.Nginx负载均衡 负载均衡可以通过负载均衡网络硬件设备和web服务器软件来实现，使用硬件设备的成本比较高,所以我们一般首选web服务器软件来实现负载均衡服务。Nginx便可以实现作为负载均衡的服务。此文介绍Nginx作为负载均衡服务的策略和配置方法，简单演示部分配置的场景。Nginx作为负载均衡服务是通过Nginx反向代理配置来实现的可以提前了解一下上一篇博客:Nginx正向代理与反向代理 二、Nginx负载均衡服务配置语法1.upstream Nginx负载均衡服务需要通过Nginx的upstream模块来实现 upstream upstreamname&#123; server1... server2... server3... ...&#125; 需要注意的是upstream是要写在http节点下 2.配置反向代理 在server节点下location里通过proxy_pass配置反向代理 server &#123; location / &#123; proxy_pass: http://upstreamname; &#125;&#125; 3.简单配置场景演示 接下来登录到服务器进行简单的配置演示。我准备了两台服务器A和B我将使用A服务器作为后端服务器的演示,B作为负载均衡中间服务器。在A服务器/etc/nginx/conf.d下我新建了3个server对应监听8001,8002,8003端口: server &#123; listen 8001; server_name localhost; location / &#123; root /opt/app/code1; index index.html index.htm; &#125;&#125;server &#123; listen 8002; server_name localhost; location / &#123; root /opt/app/code2; index index.html index.htm; &#125;&#125;server &#123; listen 8003; server_name localhost; location / &#123; root /opt/app/code3; index index.html index.htm; &#125;&#125; 并在/opt/app/下新建了3个不同样式的页面code1,code2,code3code1&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;server1&lt;/title&gt;&lt;/head&gt;&lt;body style=\"background-color:blue;\"&gt; &lt;h1&gt;this is server1&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; code2&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;server1&lt;/title&gt;&lt;/head&gt;&lt;body style=\"background-color:green;\"&gt; &lt;h1&gt;this is server2&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; code3&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;server1&lt;/title&gt;&lt;/head&gt;&lt;body style=\"background-color:red;\"&gt; &lt;h1&gt;this is server3&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 配置到这此时我访问三个端口的服务将对应不同的页面:server1:http://112.74.33.216:8001 this is server1server2:http://112.74.33.216:8002 this is server2server3:http://112.74.33.216:8003 this is server3准备好了3个服务,我们开始配置负载均衡,用一个地址代理到3个不同的服务上。登录到B服务器/etc/nginx/conf.d下新建upstream.conf配置如下:#配置upstreamupstream tangll&#123; server 112.74.33.216:8001; server 112.74.33.216:8002; server 112.74.33.216:8003;&#125;server &#123; listen 80; server_name localhost; resolver 8.8.8.8; location / &#123; #设置代理转发 proxy_pass http://tangll; &#125;&#125; 配置好了之后reload nginx我们访问B服务器地址:http://47.92.83.44结果如下:刷新后:再次刷新:反复刷新后发现访问此同样的地址访问的服务已经可以引入不同的服务器。以上便完成了Nginx负载均衡配置。由上我们还会发现每次的刷新都会按顺序访问server1,server2,server3的服务资源。其实这是Nginx作为负载均衡服务的默认调度策略:轮询。此策略下访问的请求将会按时间顺序逐一分配到不同的后端服务器。 接下来我们将介绍Ngxin作为负载均衡服务的不同调度策略。 三、Nginx作为负载均衡服务的几种调度策略1.轮询 按时间顺序注意分配到不同的后端服务器 轮询是作为Nginx负载均衡的默认调度策略 上文中已经给出演示 2.加权轮询 weight值越大,分配到的访问几率越高加权轮询策略既是在轮询的基础上指定轮询的几率weight越大,访问比率越大例如上文中的轮询策略修改如下:upstream tangll&#123; server 112.74.33.216:8001 weight=1; server 112.74.33.216:8002 weight=2; server 112.74.33.216:8003 weight=7;&#125; 则server1,server2,server3被访问的概率分别为10%,20%,70% 3.ip_hash 每个请求按访问IP的hash结果分配,这样来自同一个IP的固定访问一个后端服务器 轮询策略会有这样一个弊端,每次访问的服务可能都是不一样的,那么导致一些场景下会出现问题。像登录的cookie信息验证场景下就会出现问题,所以我们可以指定同一个ip固定访问一个后端服务器来避免这样的问题。ip_hash的配置如下:upstream tangll&#123; ip_hash; server 112.74.33.216:8001; server 112.74.33.216:8002; server 112.74.33.216:8003;&#125; 4.url_hash 按照访问的URL的hash结果来分配请求,使每个URL定向到同一个后端服务器 在ip_hash策略下还会有一些弊端,例如在服务器缓存的场景下在服务器群中可能会对应不同的服务器缓存了不同的内容。所以我们需要让相同的url下使他去访问同一个服务器的内容。url_hash配置如下:upstream tangll&#123; hash $request_uri; server 112.74.33.216:8001; server 112.74.33.216:8002; server 112.74.33.216:8003;&#125; 5.least_conn 最少连接数,哪个机器连接数少就分发给它 6.fair根据服务器的响应时间来分配请求，响应时间短的优先分配，即负载压力小的优先会分配。 7.hash关键数值 可以利用hash自定义的KEY来进行hash调度例如可以通过url中特定的KEY来调度指定的服务器 ####四、总结和补充 1.总结: Nginx使用upstream和反向代理原理可以实现负载均衡服务,使服务器群充分发挥性能,避免单位时间内单个服务器由于访问量过大而崩溃的问题。使用不同的调度策略可为不同的场景下搭建负载均衡服务。 2.补充:upstream模块下的server参数 weight默认为1,在加权轮询策略下用到: upstream tangll&#123; server 112.74.33.216:8001 weight=1; server 112.74.33.216:8002 weight=2; server 112.74.33.216:8003 weight=7;&#125; down 当前的server暂时不参与负载均衡 upstream tangll&#123; server 112.74.33.216:8001 down; server 112.74.33.216:8002; server 112.74.33.216:8003;&#125; 标识server1为无效状态,不会分配请求给他 backup 预留的备份服务器upstream tangll&#123; server 112.74.33.216:8001 backup; server 112.74.33.216:8002; server 112.74.33.216:8003;&#125; 标识server1作为备份服务器在请求server2,和server3都无法访问时才去访问server1 max_fails 允许请求失败的次数 fail_timeout 经过max_fails失败后,服务暂停的时间upstream tangll&#123; server 112.74.33.216:8001 max_fails=2 fail_timeout=10s; server 112.74.33.216:8002; server 112.74.33.216:8003;&#125; 在server1请求失败达到2次的10秒后将不会再分配请求给它 max_conns 限制最大的接受连接数upstream tangll&#123; server 112.74.33.216:8001 max_conns=100; server 112.74.33.216:8002; server 112.74.33.216:8003;&#125; 最多给server1分配100个请求,超过100个请求将不会再请求它。","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://gtntangll.github.io/tags/技术分享/"},{"name":"nginx","slug":"nginx","permalink":"https://gtntangll.github.io/tags/nginx/"}]},{"title":"Nginx正向代理与反向代理","slug":"Nginx正向代理与反向代理","date":"2018-05-04T07:53:57.000Z","updated":"2018-05-04T07:55:05.000Z","comments":true,"path":"2018/05/04/Nginx正向代理与反向代理/","link":"","permalink":"https://gtntangll.github.io/2018/05/04/Nginx正向代理与反向代理/","excerpt":"","text":"一、介绍 实践中客户端无法直接跟服务端发起请求的时候，我们就需要代理服务。代理可以实现客户端与服务端之间的通信,我们的Nginx也可以实现相应的代理服务。代理分为正向代理和反向代理,此文就来演示一下Nginx配置正向代理和反向代理的场景。 二、正向代理和反向代理的区别正向代理和反向代理的区别我在知乎上找到两张图可以帮助我们很好的理解： ######正向代理:客户端 &lt;一&gt; 代理 一&gt;服务端正向代理简单地打个租房的比方: A(客户端)想租C(服务端)的房子,但是A(客户端)并不认识C(服务端)租不到。B(代理)认识C(服务端)能租这个房子所以你找了B(代理)帮忙租到了这个房子。 这个过程中C(服务端)不认识A(客户端)只认识B(代理)C(服务端)并不知道A(客户端)租了房子，只知道房子租给了B(代理)。 ######反向代理:客户端 一&gt;代理 &lt;一&gt; 服务端反向代理也用一个租房的例子: A(客户端)想租一个房子,B(代理)就把这个房子租给了他。这时候实际上C(服务端)才是房东。B(代理)是中介把这个房子租给了A(客户端)。 这个过程中A(客户端)并不知道这个房子到底谁才是房东他都有可能认为这个房子就是B(代理)的 由上的例子和图我们可以知道正向代理和反向代理的区别在于代理的对象不一样,正向代理的代理对象是客户端,反向代理的代理对象是服务端。 三、Nginx代理的配置演示#####1、正向代理配置场景演示正向代理很常见,我们的科学上网就是一种正向代理。我们接下来演示正向代理的这么一个场景。首先我在我的A服务器的nginx设置访问控制访问控制之前我访问A下的test.html是这样的:我们打开/etc/nginx/conf.d/default.conf我们加入这么一个判断语句如果访问A的IP不是118.126.106.11(我的B服务器)则返回403.location / &#123; if ( $remote_addr !~* \"^118\\.126\\.106\\.11\") &#123; return 403; &#125; root /opt/app/demo/html; index index.html index.htm; &#125; 添加后reload一下nginx再访问test.html:此时本地我的浏览器就是被限制了,访问不了该资源。现在我登录上我的B服务器,打开/etc/nginx/conf.d/default.conf添加resolver和proxy_pass,设置如下:server &#123; listen 80; server_name localhost nginx.tangll.cn; resolver 8.8.8.8; location / &#123; proxy_pass http://$http_host$request_uri; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; resolver为DNS解析,这里填写的IP为Google提供的免费DNS服务器的IP地址proxy_pass配置代理转发至此便是配置了B服务器所有访问根一级的请求全部都代理转发对应到$http_host$request_uri去了,$http_host就是我们要访问的主机名,$request_uri就是我们后面所加的参数。简单的说至此就是相当于配置好了我们请求了B服务器,B服务器再去请求我们所请求的地址。 那么接下来我们来看一下结果,我们在本地配置好代理,我这里是mac系统,可以从网络设置中选择高级,然后选择代理填入我们B服务器的IP,然后我们来看一下代理是否成功。我们登录http://www.ip138.com/ 可以看到此时我们的IP地址已经为B服务器的IP,说明代理成功。然后我们再来访问一下test.html:结果证明,此时的客户端已经可以成功访问A服务器的资源。以上就是正向代理的一个场景演示,这个过程中可以知道,我们客户端是想要A的资源,但是A的资源只有B能拿到,便让B代理去帮助我们访问A的资源。整个过程A只知道B拿了他的资源,并不知道客户端拿到。 #####2、反向代理配置场景演示反向代理的演示更为简单一些。首先在/etc/nginx/conf.d/下新建一个test.conf:server &#123; listen 8080; server_name localhost nginx.tangll.cn; location / &#123; root /opt/app/demo/html; index index.html index.htm; &#125; error_page 500 502 503 504 404 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 可以看到我server里listen的是8080端口,但是我的服务器本身不对外开放8080端口,只开放了80端口。所以我们此时访问test.html结果是访问不到的:然后我们打开我们的/etc/nginx/conf.d/default.conf添加proxy_pass设置如下:server &#123; listen 80; server_name localhost nginx.tangll.cn; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; #设置代理 #location ~ /test.html$ &#123; # proxy_pass http://127.0.0.1:8080; #&#125; error_page 500 502 503 504 404 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 我们设置当匹配test.html结尾的URL时就去代理访问本机的8080端口为了对比我们先注释掉,然后直接80端口访问一下test.html:可以看到此时返回的404。这时候取消注释我们reload一下nginx然后用80端口访问test.html此时便可访问8080端口配置的资源。以上便是完成了一个反向代理的演示,这个过程中我们可以知道,客户端想要访问的是test.html,但是test.html实际上是8080端口下配置的,中间经过了代理才能拿到。也就是说客户端并不知道中间经历了什么代理过程,只有服务端知道。客户端只知道他拿到了test.html也就是8080端口下配置的资源内容。 四、总结 由上的打比方和演示例子可以体会到正向代理与反向代理的区别和Nginx正向代理和反向代理的简单配置。正向代理和反向代理的区别上边也说过在于代理的对象不一样,正向代理的代理对象是客户端,反向代理的代理对象是服务端。最后一句话总结此文就是代理服务器站在客户端那边就是正向代理，代理服务器站在原始服务器那边就是反向代理,Nginx通过proxy_pass可以设置代理服务。","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://gtntangll.github.io/tags/技术分享/"},{"name":"nginx","slug":"nginx","permalink":"https://gtntangll.github.io/tags/nginx/"}]},{"title":"Nginx开启gzip压缩演示","slug":"Nginx开启gzip压缩演示","date":"2018-04-24T08:37:29.000Z","updated":"2018-06-12T09:47:56.000Z","comments":true,"path":"2018/04/24/Nginx开启gzip压缩演示/","link":"","permalink":"https://gtntangll.github.io/2018/04/24/Nginx开启gzip压缩演示/","excerpt":"","text":"一、介绍 Nginx对静态资源的压缩就是在服务端进行压缩传输到浏览器端进行解压，这个压缩和解压的过程中减少中间网络传输的消耗。就是减少服务端带宽资源的消耗还有减少传输的文件大小从而实现传输的实时性。对于压缩我们可以启用Nginx的gizp压缩设置。 二、gizp配置#开启gzipgzip on; # gzip 压缩级别gzip_comp_level 2;# 启用gzip压缩的最小文件gzip_min_length 1k;# 进行压缩的文件类型。gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; 更多设置参考:Nginx文档gzip相关参数设置 三、演示首先我在服务器准备好了演示使用的图片demo.jpg接下来我们前往/etc/nginx/conf.d/新建test.conf进行设置server &#123; listen 80; server_name localhost; sendfile on; #charset koi8-r; access_log /var/log/nginx/host.access.log main; location ~ .*\\.(jpg|gif|png)$ &#123; gzip off; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; root /opt/app/demo/images; &#125;#error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 404 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 此时设置gzip off 我们访问该图片:该图片资源大小为749KB接下来我们开启gziplocation ~ .*\\.(jpg|gif|png)$ &#123; gzip on; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; root /opt/app/demo/images; &#125; reload nginx:nginx -s reload -c /etc/nginx/nginx.conf再次访问该图片:现在该图片传输资源大小被压缩为747KB可以看到确实有压缩了但是似乎压缩的比并不理想事实上gzip对文本的压缩更为显著,对图片的压缩比率并不是很理想我们同样对文本文件压缩设置来测试一下压缩的比例:我们在text.conf中增加这一段location ~ .*\\.(txt|xml)$ &#123; gzip off; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; root /opt/app/demo/doc; &#125; 然后在/opt/app/demo/doc 中准备好文本文件reload Nginx后在gzip off时访问该文本文件:此时传输资源大小为1.3MB我们将gzip打开后reload Nginx再次访问该文本:可见此时传输资源大小为12.4KB说明gzip对文本的压缩是非常理想的对比两次结果从Time第一次为9.09s到第二次50ms可以看出Nginx开启gzip压缩大大提高了网页响应的速度。","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://gtntangll.github.io/tags/技术分享/"},{"name":"nginx","slug":"nginx","permalink":"https://gtntangll.github.io/tags/nginx/"}]},{"title":"nginx的目录和配置语法","slug":"nginx的目录和配置语法","date":"2017-11-10T05:30:34.000Z","updated":"2017-11-10T05:45:16.000Z","comments":true,"path":"2017/11/10/nginx的目录和配置语法/","link":"","permalink":"https://gtntangll.github.io/2017/11/10/nginx的目录和配置语法/","excerpt":"","text":"一、nginx的各种安装目录 路径 类型 作用 /etc/logrotate.d/nginx 配置文件 nginx日志轮转用于logrotate服务的日志切割 /etc/nginx/nginx.conf/etc/nginx/conf.d/default.conf 配置文件 nginx主配置文件 /etc/nginx/fastcgi_params/etc/nginx/uwsgi_params/etc/nginx/scgi_params 配置文件 cgi配置相关fastcgi配置 /etc/nginx/koi-utf/etc/nginx/win-utf/etc/nginx/koi-win 配置文件 编码转换映射转化文件 /etc/nginx/mime.types 配置文件 设置http协议的Content-Type与扩展名对应关系 处理一些识别不了的扩展名的时候需要用到 /usr/lib/systemd/system/nginx.service/usr/lib/systemd/system/nginx-debug.service/etc/sysconfig/nginx/etc/sysconfig/nginx-debug 配置文件 用于配置出系统守护进程管理器管理方式 /usr/sbin/nginx/usr/sbin/nginx-debug 命令 nginx服务终端命令 /usr/share/doc/nginx-1.12.2/COPYRIGHT/usr/share/man/man8/nginx.8.gz 文件、目录 nginx的手册和帮助文件 /var/cache/nginx/ 目录 nginx的缓存目录 /var/log/nginx/ 目录 nginx的日志目录 二、nginx的编译配置参数命令nginx -V输出的就是nginx编译时候用到的参数 编译选项 作用 –prefix=/etc/nginx–sbin-path=/usr/sbin/nginx–modules-path=/usr/lib64/nginx/modules–conf-path=/etc/nginx/nginx.conf–error-log-path=/var/log/nginx/error.log–http-log-path=/var/log/nginx/access.log–pid-path=/var/run/nginx/pid–lock-path=/var/run/nginx.lock 安装目的目录或路径 –httpd-client-body-temp-path=/var/cache/nginx/client_temp–httpd-proxy-temp-path=/var/cache/nginx/proxy_temp–http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp–http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp–http-scgi-temp-path=/var/chache/nginx/scgi_temp 执行对应模块时，Nginx所保留的临时性文件 –user=nginx–group=nginx 设定Nginx进程启动的用户和组用户 –with-cc-opt=parameters 设置额外的参数将被添加到CFLAGS变量 –with-ld-opt=parameters 设置附加的参数，连接系统库 三、nginx.conf基础配置语法 nginx.conf基础配置语法nginx.conf 作为主配置文件include /etc/nginx/conf.d/*.conf 读到这会把该目录的.conf也读进来 全局性的和服务级别的user设置使用用户worker_processes进行增大并发连接数的处理(最好设置跟cpu保持一致)error_lognginx的错误日志pidnginx服务启动时候pid event对事件的模块worker_connections一个进程允许处理的最大连接数use定义使用的内核模型 http&#123; server&#123; listen 80; //端口 server_name localhost; //域名 location / //子目录和当前目录 &#123; root /usr/share/nginx/html; //指定目录 index index.html index.htm //默认访问页面 &#125; error_page 500 502 503 504 /50.html location = /50x.html&#123; root /usr/share/nginx/html; &#125; &#125; server&#123; ... ... &#125;&#125; 修改配置文件后需要重启nginx重启nginx(进程停掉,重新启动一次)systemctl restart nginx.service不关闭服务柔和地重启(重新读取一次配置文件)systemctl reload nginx.service","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://gtntangll.github.io/tags/技术分享/"},{"name":"nginx","slug":"nginx","permalink":"https://gtntangll.github.io/tags/nginx/"}]},{"title":"nginx快速安装","slug":"nginx基础笔记-一-nginx快速安装","date":"2017-11-09T08:34:13.000Z","updated":"2018-04-24T08:38:44.000Z","comments":true,"path":"2017/11/09/nginx基础笔记-一-nginx快速安装/","link":"","permalink":"https://gtntangll.github.io/2017/11/09/nginx基础笔记-一-nginx快速安装/","excerpt":"","text":"一、介绍 写此nginx从入门到实践系列笔记,为以教促学,让自己系统地学习掌握nginx的配置和搭建高可用架构。系统环境:centos7.2 二、nginx快速安装 访问nginx官网:nginx.org 点击download后选择最底下 stable version(稳定版本)的链接找到这里:在系统新建nginx.repo并将此官网的yum源拷贝进去vim /etc/yum.repos.d/nginx.repo 接着修改OS和OSRELEASE，我的环境为centos7.2系统故我修改如下[nginx]name=nginx repobaseurl=http://nginx.org/packages/mainline/centos/7/$basearch/gpgcheck=0enabled=1 保存后测试yum list |grep nginx 出现该列表则为成功添加接下来便可直接使用yum install nginx 来安装nginx安装完毕后测试:nginx -v 打印出nginx版本则为安装成功 三、启动nginx 安装完毕后我们来启动nginx:sudo systemctl start nginx.service 此时便可通过域名或者ip访问web页面来预览nginx的默认页面:设置开机启动nginx:sudo systemctl enable nginx.service 到此便是安装完成","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://gtntangll.github.io/tags/技术分享/"},{"name":"nginx","slug":"nginx","permalink":"https://gtntangll.github.io/tags/nginx/"}]},{"title":"python爬取贴吧帖子","slug":"python爬取贴吧帖子","date":"2017-10-20T07:03:39.000Z","updated":"2017-11-10T04:04:15.000Z","comments":true,"path":"2017/10/20/python爬取贴吧帖子/","link":"","permalink":"https://gtntangll.github.io/2017/10/20/python爬取贴吧帖子/","excerpt":"","text":"一、介绍 我们常遇到一些很长的贴吧连载帖子想存到本地再看此文就是运用python爬取指定百度贴吧的帖子并存到本地满足需求环境:python2.7目标网页:【长篇连载】剑网3的正史和野史——从头开始讲剧情故事源码存放:源码github本文参考:静觅博客python实战系列 二、页面的抓取 目标网页网址为https://tieba.baidu.com/p/2196794546满足可以选择是否只看楼主的抓取我们点一下 只看楼主 并点一下后页的链接来获取只看楼主和翻页的参数这时候可以看到只看楼主多出的参数 see_lz 和当前页的参数 pn 接下来定义一个DEMO类开始获取整个网页# -*- coding:utf-8 -*-import urllibimport urllib2import reclass DEMO: def __init__(self,baseUrl): self.baseURL = baseUrl def getPage(self): url = baseURL request = urllib2.Request(url) response = urllib2.urlopen(request) print response.read()baseURL = 'https://tieba.baidu.com/p/2196794546?see_lz=1&amp;pn=3'demo = DEMO(baseURL)demo.getPage() 运行结果: 爬取网页代码成功后我们完善一下代码,将只看楼主和页码提为参数 def __init__(self,baseUrl,seeLZ): self.baseURL = baseUrl self.seeLZ = '?see_lz=' +str(seeLZ) self.tool = Tool() def getPage(self,pageNum): try: url = self.baseURL+self.seeLZ + '&amp;pn=' + str(pageNum) request = urllib2.Request(url) response = urllib2.urlopen(request) return response.read().decode('utf-8') except urllib2.URLError, e: if hasattr(e,\"reson\"): print u\"链接失败,原因:\",e.reason return None 三、提取出想要的信息 打开目标网页审查元素（F12）首先找到帖子标题的代码段: &lt;h3 class=\"core_title_txt pull-left text-overflow \" title=\"【长篇连载】剑网3的正史和野史——从头开始讲剧情故事\" style=\"width: 416px\"&gt;【长篇连载】剑网3的正史和野史——从头开始讲剧情故事&lt;/h3&gt; 我们将提取此h3里的文本则正则表达式为:&lt;h3 class=\"core_title_txt.*?&gt;(.*?)&lt;/h3&gt; 接下来我们就可以写一个提取标题的方法:def getTitle(self,title): page = self.getPage(1) pattern = re.compile('&lt;h3 class=\"core_title_txt.*?&gt;(.*?)&lt;/h3&gt;',re.S) result = re.search(pattern,page) if result: return result.group(1).strip() else: return None 同理找到帖子页数的代码段,可得出提取页数的正则:&lt;li class=\"l_reply_num\".*?&lt;/span&gt;.*?&lt;span.*?&gt;(.*?)&lt;/span&gt; 提取页数的方法:def getPageNum(self,page): page = self.getPage(1) pattern = re.compile('&lt;li class=\"l_reply_num\".*?&lt;/span&gt;.*?&lt;span.*?&gt;(.*?)&lt;/span&gt;',re.S) result = re.search(pattern,page) if result: return result.group(1).strip() else: return None 接下来是我们主要目的,提取正文,正则为:&lt;div id=\"post_content_.*?&gt;(.*?)&lt;/div&gt; 这个正则提取出来的只是div里面的文本内容,它还会包括了图片标签，换行符，段落符等的标签。所以我们还需处理一下。这时候添加一个类利用正则将这些标签都替换掉class Tool: removeImg = re.compile('&lt;img.*?&gt;| &#123;7&#125;|') removeAddr = re.compile('&lt;a.*?&gt;|&lt;/a&gt;') replaceLine = re.compile('&lt;tr&gt;|&lt;div&gt;|&lt;/div&gt;|&lt;/p&gt;') replaceTD = re.compile('&lt;td&gt;') replacePara = re.compile('&lt;p.*?&gt;') replaceBR = re.compile('&lt;p.*?&gt;') replaceBR = re.compile('&lt;br&gt;&lt;br&gt;|&lt;br&gt;') removeExtraTag = re.compile('&lt;.*?') def replace(self,x): x = re.sub(self.removeImg,\"\",x) x = re.sub(self.removeAddr,\"\",x) x = re.sub(self.replaceLine,\"\\n\",x) x = re.sub(self.replaceTD,\"\\t\",x) x = re.sub(self.replacePara,\"\\n \",x) x = re.sub(self.replaceBR,\"\\n\",x) x = re.sub(self.removeExtraTag,\"\",x) return x.strip() 初始化类后,我们可以写提取正文的方法:def getContent(self,page): pattern = re.compile('&lt;div id=\"post_content_.*?&gt;(.*?)&lt;/div&gt;',re.S) items = re.findall(pattern,page) contents = [] for item in items: content = \"\\n\" + self.tool.replace(item) + '\\n' contents.append(content.encode('utf-8')) return contents 四、写入文件,保存为txtdef setFileTitle(self,title): if title is not None: self.file = open(title + \".txt\",\"w+\") else: self.file = open(self.defaultTitle + \".txt\",\"w+\") def writeData(self,contents): for item in contents: self.file.write(item) 五、完善代码有了以上的方法作为基础，我们来写运行的方法:def start(self): indexPage = self.getPage(1) pageNum = self.getPageNum(indexPage) title = self.getTitle(indexPage) self.setFileTitle(title) if pageNum == None: print \"URL已失效,请重试\" return None try: print \"该帖子共有\" + str(pageNum) + \"页\" for i in range(1,int(pageNum)+1): print \"正在写入第\" + str(i) + \"页数据\" page = self.getPage(i) contents = self.getContent(page) self.writeData(contents) except IOError,e: print \"写入异常,原因\" + e.message finally: print \"写入任务完成\" 此时完成的代码:# -*- coding:utf-8 -*-import urllibimport urllib2import reclass Tool: removeImg = re.compile('&lt;img.*?&gt;| &#123;7&#125;|') removeAddr = re.compile('&lt;a.*?&gt;|&lt;/a&gt;') replaceLine = re.compile('&lt;tr&gt;|&lt;div&gt;|&lt;/div&gt;|&lt;/p&gt;') replaceTD = re.compile('&lt;td&gt;') replacePara = re.compile('&lt;p.*?&gt;') replaceBR = re.compile('&lt;p.*?&gt;') replaceBR = re.compile('&lt;br&gt;&lt;br&gt;|&lt;br&gt;') removeExtraTag = re.compile('&lt;.*?') def replace(self,x): x = re.sub(self.removeImg,\"\",x) x = re.sub(self.removeAddr,\"\",x) x = re.sub(self.replaceLine,\"\\n\",x) x = re.sub(self.replaceTD,\"\\t\",x) x = re.sub(self.replacePara,\"\\n \",x) x = re.sub(self.replaceBR,\"\\n\",x) x = re.sub(self.removeExtraTag,\"\",x) return x.strip()class DEMO: def __init__(self,baseUrl,seeLZ): self.baseURL = baseUrl self.seeLZ = '?see_lz=' +str(seeLZ) self.tool = Tool() def getPage(self,pageNum): try: url = self.baseURL+self.seeLZ + '&amp;pn=' + str(pageNum) request = urllib2.Request(url) response = urllib2.urlopen(request) return response.read().decode('utf-8') except urllib2.URLError, e: if hasattr(e,\"reson\"): print u\"链接失败,原因:\",e.reason return None def getTitle(self,title): page = self.getPage(1) pattern = re.compile('&lt;h3 class=\"core_title_txt.*?&gt;(.*?)&lt;/h3&gt;',re.S) result = re.search(pattern,page) if result: return result.group(1).strip() else: return None def getPageNum(self,page): page = self.getPage(1) pattern = re.compile('&lt;li class=\"l_reply_num\".*?&lt;/span&gt;.*?&lt;span.*?&gt;(.*?)&lt;/span&gt;',re.S) result = re.search(pattern,page) if result: return result.group(1).strip() else: return None def getContent(self,page): pattern = re.compile('&lt;div id=\"post_content_.*?&gt;(.*?)&lt;/div&gt;',re.S) items = re.findall(pattern,page) contents = [] for item in items: content = \"\\n\" + self.tool.replace(item) + '\\n' contents.append(content.encode('utf-8')) return contents def setFileTitle(self,title): if title is not None: self.file = open(title + \".txt\",\"w+\") else: self.file = open(self.defaultTitle + \".txt\",\"w+\") def writeData(self,contents): for item in contents: self.file.write(item) def start(self): indexPage = self.getPage(1) pageNum = self.getPageNum(indexPage) title = self.getTitle(indexPage) self.setFileTitle(title) if pageNum == None: print \"URL已失效,请重试\" return None try: print \"该帖子共有\" + str(pageNum) + \"页\" for i in range(1,int(pageNum)+1): print \"正在写入第\" + str(i) + \"页数据\" page = self.getPage(i) contents = self.getContent(page) self.writeData(contents) except IOError,e: print \"写入异常,原因\" + e.message finally: print \"写入任务完成\"print u\"请输入帖子代号\"baseURL = 'http://tieba.baidu.com/p/' + str(raw_input(u'http://tieba.baidu.com/p/'))seeLZ = raw_input(\"是否只获取楼主发言,是输入1,否输入0\\n\")demo = DEMO(baseURL,seeLZ)demo.start() 好我们来运行一下试试:到这里输入目标网页的代号:整个运行过程:好,这时候该目录下多了这个txt文件,打开看看 文本已经成功存到本地,到这里就成功了。","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://gtntangll.github.io/tags/技术分享/"},{"name":"python","slug":"python","permalink":"https://gtntangll.github.io/tags/python/"}]}]}